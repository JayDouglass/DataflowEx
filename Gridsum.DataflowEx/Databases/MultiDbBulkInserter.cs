using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

namespace Gridsum.DataflowEx.Databases
{
    /// <summary>
    /// The class helps you to bulk insert parsed objects to multiple database tables (e.g. group by profileId)
    /// </summary>
    /// <typeparam name="T">The db-mapped type of parsed objects (usually generated by EF/linq2sql)</typeparam>
    public class MultiDbBulkInserter<T> : Dataflow<T> where T:class
    {
        private Func<T, int> m_dispatchFunc;
        private ConcurrentDictionary<int, Lazy<DbBulkInserter<T>>> m_bulkInserterMap;
        private Func<int, string> m_connectionGetter;
        private string m_destTable;
        private DataflowOptions m_options;
        private int m_bulkSize;
        private Func<int, Lazy<DbBulkInserter<T>>> m_initer;
        private ActionBlock<T> m_dispatchBlock;

        public MultiDbBulkInserter(DataflowOptions options, Func<T, int> dispatchFunc, Func<int, string> connectionGetter, string destTable, string destLabel, int bulkSize = 4096 * 2, string dbBulkInserterName = null)
            : base(options)
        {
            m_options = options;
            m_bulkInserterMap = new ConcurrentDictionary<int, Lazy<DbBulkInserter<T>>>();
            m_dispatchFunc = dispatchFunc;
            m_connectionGetter = connectionGetter;
            m_destTable = destTable;
            m_bulkSize = bulkSize;
            
            m_dispatchBlock = new ActionBlock<T>(item =>
            {
                int profileId = m_dispatchFunc(item);
                var bulkInserter = m_bulkInserterMap.GetOrAdd(profileId, m_initer).Value;
                bulkInserter.InputBlock.SafePost(item);
            }, new ExecutionDataflowBlockOptions {
                BoundedCapacity = m_dataflowOptions.RecommendedCapacity ?? int.MaxValue,
            });
            
            m_initer = p => new Lazy<DbBulkInserter<T>>(
                () =>
                {
                    var singleInserter = new DbBulkInserter<T>(
                        m_connectionGetter(p), 
                        m_destTable, 
                        m_options, 
                        destLabel,
                        m_bulkSize, string.Format("{0}_{1}", this.Name, p));

                    //Register dynamically generated blocks to enable upstream propagation
                    this.RegisterChild(singleInserter);

                    return singleInserter;
                });

            RegisterChild(m_dispatchBlock, t =>
            {
                //propagate completion to children as we don't have 'link'
                if (t.Status == TaskStatus.RanToCompletion)
                {
                    foreach (var kvPair in m_bulkInserterMap)
                    {
                        DbBulkInserter<T> singleProfileInserter = kvPair.Value.Value;
                        singleProfileInserter.InputBlock.Complete();
                    }
                }

                //no need to propagate errors as register handles that (given that dyamic blocks are registered)
            });
        }
        
        public override ITargetBlock<T> InputBlock
        {
            get { return m_dispatchBlock; }
        }
    }
}
