using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

namespace Gridsum.DataflowEx.Databases
{
    using System.Data.SqlClient;

    /// <summary>
    /// The class helps you to bulk insert parsed objects to multiple database tables (e.g. group by profileId)
    /// </summary>
    /// <typeparam name="T">The db-mapped type of parsed objects (usually generated by EF/linq2sql)</typeparam>
    public class MultiDbBulkInserter<T> : Dataflow<T> where T:class
    {
        private Func<T, int> m_dispatchFunc;
        private ConcurrentDictionary<int, Lazy<DbBulkInserter<T>>> m_bulkInserterMap;
        private Func<int, string> m_connectionGetter;
        private string m_destTable;
        private DataflowOptions m_options;
        private int m_bulkSize;
        private readonly string m_displayName;
        private Func<int, Lazy<DbBulkInserter<T>>> m_initer;
        private ActionBlock<T> m_dispatchBlock;

        public MultiDbBulkInserter(DataflowOptions options, 
            Func<T, int> dispatchFunc, 
            Func<int, string> connectionGetter, 
            string destTable, 
            string destLabel, 
            int bulkSize = 4096 * 2, 
            string displayName = null,
            PostBulkInsertDelegate postBulkInsert = null)
            : base(options)
        {
            m_options = options;
            m_bulkInserterMap = new ConcurrentDictionary<int, Lazy<DbBulkInserter<T>>>();
            m_dispatchFunc = dispatchFunc;
            m_connectionGetter = connectionGetter;
            m_destTable = destTable;
            m_bulkSize = bulkSize;
            m_displayName = displayName;

            m_dispatchBlock = new ActionBlock<T>(item =>
            {
                int profileId = m_dispatchFunc(item);
                var bulkInserter = m_bulkInserterMap.GetOrAdd(profileId, m_initer).Value;
                bulkInserter.InputBlock.SafePost(item);
            }, new ExecutionDataflowBlockOptions {
                BoundedCapacity = m_dataflowOptions.RecommendedCapacity ?? int.MaxValue,
            });
            
            m_initer = pid => new Lazy<DbBulkInserter<T>>(
                () =>
                {
                    var singleInserter = this.CreateDbBulkInserter(destLabel, postBulkInsert, pid);

                    //Register dynamically generated blocks to enable upstream propagation
                    this.RegisterChild(singleInserter);

                    return singleInserter;
                });

            RegisterChild(m_dispatchBlock, t =>
            {
                //propagate completion to children as we don't have 'link'
                if (t.Status == TaskStatus.RanToCompletion)
                {
                    foreach (var kvPair in m_bulkInserterMap)
                    {
                        DbBulkInserter<T> singleProfileInserter = kvPair.Value.Value;
                        singleProfileInserter.InputBlock.Complete();
                    }
                }

                //no need to propagate errors as register handles that (given that dyamic blocks are registered)
            });
        }

        protected virtual DbBulkInserter<T> CreateDbBulkInserter(string destLabel, PostBulkInsertDelegate postBulkInsert, int pid)
        {
            return new DbBulkInserter<T>(
                this.m_connectionGetter(pid), 
                this.m_destTable, 
                this.m_options, 
                destLabel,
                this.m_bulkSize, 
                string.Format("childDbBulkInserter_{0}", pid), 
                postBulkInsert);
        }

        public override ITargetBlock<T> InputBlock
        {
            get { return m_dispatchBlock; }
        }

        public override string Name
        {
            get
            {
                return m_displayName ?? base.Name;
            }
        }
    }
}
